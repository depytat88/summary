<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>


<h4>Внешние скрипты, порядок исполнения</h4>

<p>
    <ul>
        <li>
            Скрипты вставляются на страницу как текст в теге \<script\>, либо как внешний файл через \<\script src\=\"путь\">\<\/script\>
        </li>
        <li>
            Специальные атрибуты async и defer используются для того, чтобы пока грузится внешний скрипт – браузер показал остальную (следующую за ним) часть страницы. Без них этого не происходит.
        </li>
        <li>
            Разница между async и defer: атрибут defer сохраняет относительную последовательность скриптов, а async – нет. Кроме того, defer всегда ждёт, пока весь HTML-документ будет готов, а async – нет.
        </li>
    </ul>
</p>

<hr/>

<h4>ES5-shim</h4>

<p>
    Браузер IE8 поддерживает только совсем старую версию стандарта JavaScript, а именно ES3.

    К счастью, многие возможности современного стандарта можно добавить в этот браузер, подключив библиотеку ES5 shim, а именно – скрипты es5-shim.js и es5-sham.js из неё.
</p>

<hr/>


<h4>Переменные</h4>

<p>
    var user = 'John', age = 25, message = 'Hello';
    <br/>
    <ol>
        <li>Имя может состоять из: букв, цифр, символов $ и _</li>
        <li>Первый символ не должен быть цифрой.</li>
    </ol>
        Константа – это переменная, которая никогда не меняется. Как правило, их называют большими буквами, через подчёркивание. Например:
<br/>
var COLOR_RED = "#F00";
</p>

<hr/>

<h4>typeof</h4>
<p>
    Есть 5 «примитивных» типов: number, string, boolean, null, undefined и 6-й тип – объекты object.
</p>
<p>
    typeof undefined // "undefined"
    <br/>
    typeof 0 // "number"
    <br/>
    typeof true // "boolean"
    <br/>
    typeof "foo" // "string"
    <br/>
    typeof {} // "object"
    <br/>
    typeof null // "object"  (1)
    <br/>
    typeof function(){} // "function"  (2)
</p>
<hr/>

<h4>операторы</h4>

<p>
    Сложение строк, бинарный +
    <br/>
    Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!
</p>

<p>
    Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.
    <br/>
    alert( 2 - '1' ); // 1
    <br/>
    alert( 6 / '2' ); // 3
    <br/>

    +apples   приводит к числу
</p>

<p>
    n = n + 5;
    <br/>
    n = n * 2;
    <br/>
    n += 5; // теперь n=7 (работает как n = n + 5)
    <br/>
    n *= 2; // теперь n=14 (работает как n = n * 2)
</p>

<hr/>

<h4>Операторы сравнения и логические значения</h4>

<p>
    Если строка состоит из нескольких букв, то сравнение осуществляется как в телефонной книжке или в словаре. Сначала сравниваются первые буквы, потом вторые, и так далее, пока одна не будет больше другой.
</p>

<h3>
    При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям.
</h3>

<p>
    alert( '2' > 1 ); // true, сравнивается как 2 > 1
    <br/>
    alert( '01' == 1 ); // true, сравнивается как 1 == 1
    <br/>
    alert( false == 0 ); // true, false становится числом 0
    <br/>
    alert( true == 1 ); // true, так как true становится числом 1.
    <br/>
    В обычном операторе == есть «проблема» – он не может отличить 0 от false:
</p>

<ul>
    <li>
        Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
    </li>
    <li>
        При преобразовании в число null становится 0, а undefined становится NaN.
    </li>
</ul>

<p>
    alert( null > 0 ); // false
    <br/>
    alert( null == 0 ); // false
    <br/>
    alert(null >= 0); // true
    <br/>
    Значение undefined вообще нельзя сравнивать:
</p>

<hr/>

<h4>prompt</h4>

<p>
    result = prompt(title, default);
    <br/>
    Она выводит модальное окно с заголовком title, полем для ввода текста, заполненным строкой по умолчанию default и кнопками OK/CANCEL
    <br/>
    Всегда указывайте default ибо IE вставит в диалог значение по умолчанию "undefined".
</p>

<hr/>

<h4>confirm</h4>
<p>
    result = confirm(question);
</p>
<p>
    confirm выводит окно с вопросом question с двумя кнопками: OK и CANCEL.
    <br/>
    Результатом будет true при нажатии OK и false – при CANCEL(Esc).
</p>

<hr/>

<h4>Оператор вопросительный знак „?“  «Тернарный оператор»</h4>

<p>
    условие ? значение1 : значение2
    <br/>
    access = (age > 14) ? true : false;
</p>
<hr/>
<h4>или || </h4>

<h3>Короткий цикл вычислений</h3>

<p>
    JavaScript вычисляет несколько ИЛИ слева направо. При этом, чтобы экономить ресурсы, используется так называемый «короткий цикл вычисления».
</p>

<p>Если все значения «ложные», то || возвратит последнее из них
    <br/>
    alert( undefined || '' || false || 0 ); // 0
</p>

<h4>
    и &&
</h4>

<p>
    Если левый аргумент – false, оператор И возвращает его и заканчивает вычисления. Иначе – вычисляет и возвращает правый аргумент.
    <br/>
    Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.
</p>

<h4>двойное не !!</h4>
<p>
    В частности, двойное НЕ используют для преобразования значений к логическому типу:
    <br/>
    alert( !!"строка" ); // true
    <br/>
    alert( !!null ); // false
</p>
<hr/>


<h3>Преобразование типов для примитивов</h3>

<h4>Строковое преобразование</h4>

<p>
    Например, его производит функция alert.
    <br/>
    Можно также осуществить преобразование явным вызовом String(val):
    <br/>
    alert( String(null) === "null" ); // true
    <br/>
    Как видно из примеров выше, преобразование происходит наиболее очевидным способом, «как есть»: false становится "false", null – "null", undefined – "undefined" и т.п.
    <br/>
    Также для явного преобразования применяется оператор "+", у которого один из аргументов строка. В этом случае он приводит к строке и другой аргумент, например:
</p>

<h4>
    Численное преобразование
</h4>

<p>
    Численное преобразование происходит в математических функциях и выражениях, а также при сравнении данных различных типов (кроме сравнений ===, !==).
    <br/>
    Для преобразования к числу в явном виде можно вызвать Number(val), либо, что короче, поставить перед выражением унарный плюс "+":
    <br/>
    var a = +"123"; // 123
    <br/>
    var a = Number("123"); // 123, тот же эффект
    <br/>
    alert( +true ); // 1
    <br/>
    alert( +false ); // 0
</p>

<h4>Логическое преобразование</h4>

<p>
    Преобразование к true/false происходит в логическом контексте, таком как if(value), и при применении логических операторов.
    <br/>
    Все значения, которые интуитивно «пусты», становятся false. Их несколько: 0, пустая строка, null, undefined и NaN.
    <br/>
    Объекты	Всегда true
    <br/>
    alert( !!"0" ); // true
    <br/>
    alert( !!" " ); // любые непустые строки, даже из пробелов - true!
</p>

<hr/>
<h4>Повторение цикла по-научному называется «итерация». Цикл в примере выше совершает три итерации.</h4>
<hr/>

<h4>switch</h4>
<p>
    Несколько значений case можно группировать.
    <br/>
    switch (a) {
    <br/>
    case 4:
    <br/>
    alert('Верно!');
    <br/>
    break;
    <br/>
    case 3:                    // (*)
    <br/>
    case 5:                    // (**)
    <br/>
    alert('Неверно!');
    <br/>
    alert('Немного ошиблись, бывает.');
    <br/>
    break;
    <br/>
    default:
    <br/>
    alert('Странный результат, очень странный');
    <br/>
    }
</p>

<hr/>

<h4>Неважно, где именно в функции и сколько раз объявляется переменная. Любое объявление срабатывает один раз и распространяется на всю функцию.</h4>
<br/>
если в функцииобъявленна переменная без var то по умолчанию объявится глобальная переменная
<hr/>

<h4>Параметры копируются в локальные переменные функции.</h4>

<p>
    Например, в коде ниже есть внешняя переменная from, значение которой при запуске функции копируется в параметр функции с тем же именем. Далее функция работает уже с параметром:
</p>

function showMessage(from, text) {<br/>
from = '**' + from + '**'; // меняем локальную переменную from<br/>
alert( from + ': ' + text );<br/>
}<br/>
<br/>
var from = "Маша";<br/>
<br/>
showMessage(from, "Привет");<br/>
<br/>
alert( from ); // старое значение from без изменений, в функции была изменена копия<br/>


<p>
    Присвое значения аргумента по умолчанию
    <br/>
    function showMessage(from, text) {<br/>
    text = text || 'текст не передан';<br/>
    <br/>
    ...<br/>
    }<br/>
</p>

<p>
    В случае, когда функция не вернула значение или return был без аргументов, считается что она вернула undefined:
</p>

<hr/>

<h4>Сравнение Function Expression с Function Declaration</h4>

<p>
    Иногда в коде начинающих разработчиков можно увидеть много Function Expression. Почему-то, видимо, не очень понимая происходящее, функции решают создавать как var func = function(), но в большинстве случаев обычное объявление функции – лучше.
    <br/>

    Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.
    <br/>
    sayHi("Вася"); // Привет, Вася <br/>
    <br/>
    function sayHi(name) { <br/>
    alert( "Привет, " + name ); <br/>
    }

    <br/>
    Function Declaration при use strict видны только внутри блока, в котором объявлены. Так как код в учебнике выполняется в режиме use strict, то будет ошибка.
    <br/>
    var age = +prompt("Сколько вам лет?", 20);<br/>
    <br/>
    if (age >= 18) {<br/>
    function sayHi() {<br/>
    alert( 'Прошу вас!' );<br/>
    }<br/>
    } else {<br/>
    function sayHi() {<br/>
    alert( 'До 18 нельзя' );<br/>
    }<br/>
    }<br/>

    sayHi();
</p>
<hr/>

<h4>new Function</h4>

<p>
    Существует ещё один способ создания функции, который используется очень редко, но упомянем и его для полноты картины.
    <br/>
    var sum = new Function('a,b', ' return a+b; ');
    <br/>
    var result = sum(1, 2);<br/>
    alert( result ); // 3
</p>
<hr/>

<p>
    Частный случай подвызова – когда функция вызывает сама себя. Это называется рекурсией.
    <br/>
    pow(x, n) = x * pow(x, n - 1)
</p>

<hr/>

<p>
    Как правило, лучше располагать функции под кодом, который их использует.
    <br/>
    Сначала код, а описание функций внизу
</p>
<hr/>

<h4>Метод num.toFixed(n)</h4>

<p>
    К методу числа можно обратиться и напрямую:
    <br/>
    alert( 12.34.toFixed(1) ); // 12.3
    <br/>
    …Но если число целое, то будет проблема:
    <br/>
    alert(12.toFixed(1)); // ошибка!
    <br/>
    Это – особенность синтаксиса JavaScript. Вот так – будет работать:
    <br/>
    alert( 12..toFixed(1) ); // 12.0
</p>

<hr/>

<p>
    Также доступна запись в «научном формате» (ещё говорят «запись с плавающей точкой»), который выглядит как 'число'e'кол-во нулей'.
    <br/>
    // еще пример научной формы: 3 с 5 нулями <br/>
    alert( 3e5 ); // 300000
</p>

<hr/>

<h4>Деление на 0</h4>

<p>
    alert( 1 / 0 ); // Infinity <br/>
    alert( 12345 / 0 ); // Infinity <br/>
    alert( -1 / 0 ); // -Infinity <br/>
    Бесконечность можно получить также, если сделать ну очень большое число, для которого количество разрядов в двоичном представлении не помещается в соответствующую часть стандартного 64-битного формата, например:
    <br/>
    alert( 1e500 ); // Infinity
</p>

<hr/>

<h4>NaN</h4>
<p>Если математическая операция не может быть совершена, то возвращается специальное значение NaN (Not-A-Number).
    <br/>
    Например, деление 0/0 в математическом смысле неопределено, поэтому его результат NaN:
    <br/>
    alert( 0 / 0 ); // NaN
    <br/>
    Значение NaN – единственное, в своем роде, которое не равно ничему, включая себя.
    <br/>
    Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true, если получилось NaN, и false – для любого другого значения.
    <br/>
    Значение NaN «прилипчиво». Любая операция с NaN возвращает NaN.
    <br/>
    alert( NaN + 1 ); // NaN
    <br/>
    Отсюда вытекает забавный способ проверки значения на NaN: можно проверить значение на равенство самому себе, если не равно – то NaN:
</p>

<hr/>

Функция parseInt читает из строки целое число, а parseFloat – дробное.
<br/>
alert( parseInt('12px') ) // 12, ошибка на символе 'p'<br/>
alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке <br/>

Функция parseInt также позволяет указать систему счисления, то есть считывать числа, заданные в шестнадцатиричной и других системах счисления:
<br/>
alert( parseInt('FF', 16) ); // 255
<br/>
Если же нужна действительно точная проверка на число, которая не считает числом строку из пробелов, логические и специальные значения, а также отсекает Infinity – используйте следующую функцию isNumeric:
<br/>
function isNumeric(n) {<br/>
return !isNaN(parseFloat(n)) && isFinite(n);<br/>
}
<hr/>

<h4>Итого про цифры</h4>

<ul>
    <li>Числа могут быть записаны в шестнадцатиричной, восьмеричной системе, а также «научным» способом.</li>
    <li>В JavaScript существует числовое значение бесконечность Infinity.</li>
    <li>Ошибка вычислений дает NaN.</li>
    <li>Арифметические и математические функции преобразуют строку в точности в число, игнорируя начальные и конечные пробелы.</li>
    <li>Функции parseInt/parseFloat делают числа из строк, которые начинаются с числа.</li>
    <li>Есть четыре способа округления: Math.floor, Math.round, Math.ceil и битовый оператор. Для округления до нужного знака используйте +n.toFixed(p) или трюк с умножением и делением на 10p.</li>
    <li>Дробные числа дают ошибку вычислений. При необходимости ее можно отсечь округлением до нужного знака.</li>
    <li>Случайные числа от 0 до 1 генерируются с помощью Math.random(), остальные – преобразованием из них.</li>
</ul>

<hr/>


<p>
    Экранирование специальных символов
    <br/>
    var str = 'I\'m a JavaScript programmer';
</p>

<hr/>

<h1>Строки</h1>

<h4>Доступ к символам</h4>

<p>
    var str = "jQuery"; <br/>
    alert( str.charAt(0) ); // "j" <br/>

    var str = "Я - современный браузер!"; <br/>
    alert( str[0] ); // "Я" <br/>

    разница <br/>
    alert( "".charAt(0) ); // пустая строка <br/>
    alert( "" [0] ); // undefined <br/>
    Вообще же метод charAt существует по историческим причинам, ведь квадратные скобки – проще и короче.
</p>

<p>
    slice <br/>
    Отрицательные значения отсчитываются от конца строки: <br/>
    alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца. <br/>
    Это гораздо более удобно, чем странная логика substring.
</p>
<p>
    Как мы знаем, символы сравниваются в алфавитном порядке 'А' < 'Б' < 'В' < ... < 'Я'.
    <br/>
    var str = "Ёлки";
    <br/>
    alert( str.localeCompare("Яблони") ); // -1 <br/>
    Метод str1.localeCompare(str2) возвращает -1, если str1 < str2, 1, если str1 > str2 и 0, если они равны.
</p>

<hr/>

<h4>Создание объектов</h4>

<p>
    1. o = new Object(); <br/>
    2. o = {}; // пустые фигурные скобки <br/>

    Обычно все пользуются синтаксисом (2), т.к. он короче. <br/>

    Иногда бывает нужно проверить, есть ли в объекте свойство с определенным ключом. <br/>
    if ("name" in person) { <br/>
    alert( "Свойство name существует!" );<br/>
    }<br/>

    Впрочем, чаще используется другой способ – сравнение значения с undefined. <br/>
    Дело в том, что в JavaScript можно обратиться к любому свойству объекта, даже если его нет.<br/>

    Ошибки не будет.<br/>

    Но если свойство не существует, то вернется специальное значение undefined:<br/>
    Но бывает, что технически возможно, что свойство есть, а его значением является undefined: <br/>
    Но оператор in гарантирует правильный результат: <br/>

    Записи person['name'] и person.name идентичны, но квадратные скобки позволяют использовать в качестве имени свойства любую строку:
    <br/>

    person['любимый стиль музыки'] = 'Джаз'; <br/>
    Доступ через точку используется, если мы на этапе написания программы уже знаем название свойства. А если оно будет определено по ходу выполнения, например, введено посетителем и записано в переменную, то единственный выбор – квадратные скобки.
</p>

<hr/>

<h4>Объекты: перебор свойств</h4>

<p>
    for (key in obj) { <br/>
    /* ... делать что-то с obj[key] ... */<br/>
    }<br/>

    Количество свойств в объекте <br/>
    for (var key in menu) { <br/>
    counter++; <br/>
    } <br/>

    Правда ли, что при переборе for(key in codes) ключи key будут перечислены именно в том порядке, в котором заданы?
    <br/>




<ul>
    <li>По стандарту – нет. Но некоторое соглашение об этом, всё же, есть.</li>
    <li>Цикл по ключам: for (key in obj).</li>
    <li>
        Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах).
        Если нужно, чтобы порядок перебора числовых ключей соответствовал их объявлению в объекте, то используют трюк:
        числовые ключи заменяют на похожие, но содержащие не только цифры.
        Например, добавляют в начало +, как описано в примере выше, а потом, в процессе обработки, преобразуют такие ключи в числа.
    </li>
</ul>
</p>

<hr/>
<h4>Клонирование объектов</h4>
<p>
    Иногда, на практике – очень редко, нужно скопировать объект целиком, создать именно полную независимую копию, «клон» объекта.

    Что ж, можно сделать и это. Для этого нужно пройти по объекту, достать данные и скопировать на уровне примитивов.
    <br/>
    // скопируем в него все свойства user <br/>
    for (var key in user) { <br/>
    clone[key] = user[key]; <br/>
    } <br/>


    При «раскрытии» свойств объекта в консоли – браузер всегда выводит их текущие (на момент раскрытия) значения.

    <br/>
    )
</p>

<hr/>

<h4>Массивы</h4>
<p>
    Через alert можно вывести и массив целиком. <br/>

    Методы push/pop выполняются быстро, а shift/unshift – медленно. (потомучто не трогают весь массив

    <br/>
    Перебор элементов
    <br/>

    for (var i = 0; i < arr.length; i++) {  <br/>
    alert( arr[i] );  <br/>
    }  <br/>

    Не используйте for..in для массивов
    <br/>
    Если коротко: цикл for(var i=0; i < arr.length...) надёжнее и быстрее.
    <br/>
    Длина length – не количество элементов массива, а последний индекс + 1.
    <br/>
    При уменьшении length массив укорачивается.
    <br/>
    Существует еще один синтаксис для создания массива:
    <br/>
    var arr = new Array("Яблоко", "Груша", "и т.п.");
    <br/>
    Он редко используется, т.к. квадратные скобки [] короче.
</p>


</body>
</html>