<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>


<h4>Внешние скрипты, порядок исполнения</h4>

<p>
    <ul>
        <li>
            Скрипты вставляются на страницу как текст в теге \<script\>, либо как внешний файл через \<\script src\=\"путь\">\<\/script\>
        </li>
        <li>
            Специальные атрибуты async и defer используются для того, чтобы пока грузится внешний скрипт – браузер показал остальную (следующую за ним) часть страницы. Без них этого не происходит.
        </li>
        <li>
            Разница между async и defer: атрибут defer сохраняет относительную последовательность скриптов, а async – нет. Кроме того, defer всегда ждёт, пока весь HTML-документ будет готов, а async – нет.
        </li>
    </ul>
</p>

<hr/>

<h4>ES5-shim</h4>

<p>
    Браузер IE8 поддерживает только совсем старую версию стандарта JavaScript, а именно ES3.

    К счастью, многие возможности современного стандарта можно добавить в этот браузер, подключив библиотеку ES5 shim, а именно – скрипты es5-shim.js и es5-sham.js из неё.
</p>

<hr/>


<h4>Переменные</h4>

<p>
    var user = 'John', age = 25, message = 'Hello';
    <br/>
    <ol>
        <li>Имя может состоять из: букв, цифр, символов $ и _</li>
        <li>Первый символ не должен быть цифрой.</li>
    </ol>
        Константа – это переменная, которая никогда не меняется. Как правило, их называют большими буквами, через подчёркивание. Например:
<br/>
var COLOR_RED = "#F00";
</p>

<hr/>

<h4>typeof</h4>
<p>
    Есть 5 «примитивных» типов: number, string, boolean, null, undefined и 6-й тип – объекты object.
</p>
<p>
    typeof undefined // "undefined"
    <br/>
    typeof 0 // "number"
    <br/>
    typeof true // "boolean"
    <br/>
    typeof "foo" // "string"
    <br/>
    typeof {} // "object"
    <br/>
    typeof null // "object"  (1)
    <br/>
    typeof function(){} // "function"  (2)
</p>
<hr/>

<h4>операторы</h4>

<p>
    Сложение строк, бинарный +
    <br/>
    Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!
</p>

<p>
    Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.
    <br/>
    alert( 2 - '1' ); // 1
    <br/>
    alert( 6 / '2' ); // 3
    <br/>

    +apples   приводит к числу
</p>

<p>
    n = n + 5;
    <br/>
    n = n * 2;
    <br/>
    n += 5; // теперь n=7 (работает как n = n + 5)
    <br/>
    n *= 2; // теперь n=14 (работает как n = n * 2)
</p>

<hr/>

<h4>Операторы сравнения и логические значения</h4>

<p>
    Если строка состоит из нескольких букв, то сравнение осуществляется как в телефонной книжке или в словаре. Сначала сравниваются первые буквы, потом вторые, и так далее, пока одна не будет больше другой.
</p>

<h3>
    При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям.
</h3>

<p>
    alert( '2' > 1 ); // true, сравнивается как 2 > 1
    <br/>
    alert( '01' == 1 ); // true, сравнивается как 1 == 1
    <br/>
    alert( false == 0 ); // true, false становится числом 0
    <br/>
    alert( true == 1 ); // true, так как true становится числом 1.
    <br/>
    В обычном операторе == есть «проблема» – он не может отличить 0 от false:
</p>

<ul>
    <li>
        Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
    </li>
    <li>
        При преобразовании в число null становится 0, а undefined становится NaN.
    </li>
</ul>

<p>
    alert( null > 0 ); // false
    <br/>
    alert( null == 0 ); // false
    <br/>
    alert(null >= 0); // true
    <br/>
    Значение undefined вообще нельзя сравнивать:
</p>

<hr/>

<h4>prompt</h4>

<p>
    result = prompt(title, default);
    <br/>
    Она выводит модальное окно с заголовком title, полем для ввода текста, заполненным строкой по умолчанию default и кнопками OK/CANCEL
    <br/>
    Всегда указывайте default ибо IE вставит в диалог значение по умолчанию "undefined".
</p>

<hr/>

<h4>confirm</h4>
<p>
    result = confirm(question);
</p>
<p>
    confirm выводит окно с вопросом question с двумя кнопками: OK и CANCEL.
    <br/>
    Результатом будет true при нажатии OK и false – при CANCEL(Esc).
</p>

<hr/>

<h4>Оператор вопросительный знак „?“  «Тернарный оператор»</h4>

<p>
    условие ? значение1 : значение2
    <br/>
    access = (age > 14) ? true : false;
</p>
<hr/>
<h4>или || </h4>

<h3>Короткий цикл вычислений</h3>

<p>
    JavaScript вычисляет несколько ИЛИ слева направо. При этом, чтобы экономить ресурсы, используется так называемый «короткий цикл вычисления».
</p>

<p>Если все значения «ложные», то || возвратит последнее из них
    <br/>
    alert( undefined || '' || false || 0 ); // 0
</p>

<h4>
    и &&
</h4>

<p>
    Если левый аргумент – false, оператор И возвращает его и заканчивает вычисления. Иначе – вычисляет и возвращает правый аргумент.
    <br/>
    Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.
</p>

<h4>двойное не !!</h4>
<p>
    В частности, двойное НЕ используют для преобразования значений к логическому типу:
    <br/>
    alert( !!"строка" ); // true
    <br/>
    alert( !!null ); // false
</p>
<hr/>


<h3>Преобразование типов для примитивов</h3>

<h4>Строковое преобразование</h4>

<p>
    Например, его производит функция alert.
    <br/>
    Можно также осуществить преобразование явным вызовом String(val):
    <br/>
    alert( String(null) === "null" ); // true
    <br/>
    Как видно из примеров выше, преобразование происходит наиболее очевидным способом, «как есть»: false становится "false", null – "null", undefined – "undefined" и т.п.
    <br/>
    Также для явного преобразования применяется оператор "+", у которого один из аргументов строка. В этом случае он приводит к строке и другой аргумент, например:
</p>

<h4>
    Численное преобразование
</h4>

<p>
    Численное преобразование происходит в математических функциях и выражениях, а также при сравнении данных различных типов (кроме сравнений ===, !==).
    <br/>
    Для преобразования к числу в явном виде можно вызвать Number(val), либо, что короче, поставить перед выражением унарный плюс "+":
    <br/>
    var a = +"123"; // 123
    <br/>
    var a = Number("123"); // 123, тот же эффект
    <br/>
    alert( +true ); // 1
    <br/>
    alert( +false ); // 0
</p>

<h4>Логическое преобразование</h4>

<p>
    Преобразование к true/false происходит в логическом контексте, таком как if(value), и при применении логических операторов.
    <br/>
    Все значения, которые интуитивно «пусты», становятся false. Их несколько: 0, пустая строка, null, undefined и NaN.
    <br/>
    Объекты	Всегда true
    <br/>
    alert( !!"0" ); // true
    <br/>
    alert( !!" " ); // любые непустые строки, даже из пробелов - true!
</p>

<hr/>
<h4>Повторение цикла по-научному называется «итерация». Цикл в примере выше совершает три итерации.</h4>
<hr/>

<h4>switch</h4>
<p>
    Несколько значений case можно группировать.
    <br/>
    switch (a) {
    <br/>
    case 4:
    <br/>
    alert('Верно!');
    <br/>
    break;
    <br/>
    case 3:                    // (*)
    <br/>
    case 5:                    // (**)
    <br/>
    alert('Неверно!');
    <br/>
    alert('Немного ошиблись, бывает.');
    <br/>
    break;
    <br/>
    default:
    <br/>
    alert('Странный результат, очень странный');
    <br/>
    }
</p>

<hr/>

<h4>Неважно, где именно в функции и сколько раз объявляется переменная. Любое объявление срабатывает один раз и распространяется на всю функцию.</h4>
<br/>
если в функцииобъявленна переменная без var то по умолчанию объявится глобальная переменная
<hr/>

<h4>Параметры копируются в локальные переменные функции.</h4>

<p>
    Например, в коде ниже есть внешняя переменная from, значение которой при запуске функции копируется в параметр функции с тем же именем. Далее функция работает уже с параметром:
</p>

function showMessage(from, text) {<br/>
from = '**' + from + '**'; // меняем локальную переменную from<br/>
alert( from + ': ' + text );<br/>
}<br/>
<br/>
var from = "Маша";<br/>
<br/>
showMessage(from, "Привет");<br/>
<br/>
alert( from ); // старое значение from без изменений, в функции была изменена копия<br/>


<p>
    Присвое значения аргумента по умолчанию
    <br/>
    function showMessage(from, text) {<br/>
    text = text || 'текст не передан';<br/>
    <br/>
    ...<br/>
    }<br/>
</p>

<p>
    В случае, когда функция не вернула значение или return был без аргументов, считается что она вернула undefined:
</p>

<hr/>

<h4>Сравнение Function Expression с Function Declaration</h4>

<p>
    Иногда в коде начинающих разработчиков можно увидеть много Function Expression. Почему-то, видимо, не очень понимая происходящее, функции решают создавать как var func = function(), но в большинстве случаев обычное объявление функции – лучше.
    <br/>

    Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.
    <br/>
    sayHi("Вася"); // Привет, Вася <br/>
    <br/>
    function sayHi(name) { <br/>
    alert( "Привет, " + name ); <br/>
    }

    <br/>
    Function Declaration при use strict видны только внутри блока, в котором объявлены. Так как код в учебнике выполняется в режиме use strict, то будет ошибка.
    <br/>
    var age = +prompt("Сколько вам лет?", 20);<br/>
    <br/>
    if (age >= 18) {<br/>
    function sayHi() {<br/>
    alert( 'Прошу вас!' );<br/>
    }<br/>
    } else {<br/>
    function sayHi() {<br/>
    alert( 'До 18 нельзя' );<br/>
    }<br/>
    }<br/>

    sayHi();
</p>
<hr/>

<h4>new Function</h4>

<p>
    Существует ещё один способ создания функции, который используется очень редко, но упомянем и его для полноты картины.
    <br/>
    var sum = new Function('a,b', ' return a+b; ');
    <br/>
    var result = sum(1, 2);<br/>
    alert( result ); // 3
</p>
<hr/>

<p>
    Частный случай подвызова – когда функция вызывает сама себя. Это называется рекурсией.
    <br/>
    pow(x, n) = x * pow(x, n - 1)
</p>

<hr/>

<p>
    Как правило, лучше располагать функции под кодом, который их использует.
    <br/>
    Сначала код, а описание функций внизу
</p>



</body>
</html>